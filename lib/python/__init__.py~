#!/usr/bin/env python

''' system '''
from string import Template
import copy
import getopt
import json
import logging
import logging.handlers
import os
import shlex
import shutil
import string
import subprocess
import sys
import time
import traceback

# third-party 
from Pegasus.DAX3 import ADAG
from Pegasus.DAX3 import Executable
from Pegasus.DAX3 import File
from Pegasus.DAX3 import Job
from Pegasus.DAX3 import Link
from Pegasus.DAX3 import PFN
from Pegasus.DAX3 import Profile
from Pegasus.DAX3 import Transformation

# local #
from graphml import Edge
from graphml import GraphMLParser
from graphml import Node

# Execute a command via the shell #
class Executor:

    def __init__(self, context):
        self.context = context

    def execute (self, command, pipe=True):
        template = Template (command)
        textCommand = template.substitute (self.context)
	logging.info ("\n   --command: %s\n   --context: %s\n   --text   : %s" % 
		      (command,
		       self.context,
		       textCommand))
	os.system (textCommand)

# emit pegasus site xml #	
class SiteXML:
    def __init__(self):
        self.xml = """<?xml version="1.0" encoding="UTF-8"?>
<sitecatalog
    xmlns="http://pegasus.isi.edu/schema/sitecatalog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pegasus.isi.edu/schema/sitecatalog http://pegasus.isi.edu/schema/sc-3.0.xsd"
    version="3.0">
    <site  handle="local" arch="x86" os="LINUX">
        <grid  type="gt2" contact="localhost/jobmanager-fork" scheduler="Fork" jobtype="auxillary"/>
        <head-fs>
            <scratch>
                <shared>
                    <file-server protocol="file" url="file://" mount-point="${TOPDIR}/outputs"/>
                    <internal-mount-point mount-point="${TOPDIR}/work/outputs" free-size="100G" total-size="30G"/>
                </shared>
            </scratch>
            <storage>
                <shared>
                    <file-server protocol="file" url="file://" mount-point="${TOPDIR}/outputs"/>
                    <internal-mount-point mount-point="${TOPDIR}/work/outputs" free-size="100G" total-size="30G"/>
                </shared>
            </storage>
        </head-fs>
        <replica-catalog  type="LRC" url="rlsn://dummyValue.url.edu" />
        <profile namespace="env" key="PEGASUS_HOME" >${PEGASUS_HOME}</profile>
        <profile namespace="env" key="GLOBUS_LOCATION" >${GLOBUS_LOCATION}</profile>
    </site>
    <site  handle="${CLUSTER_ID}" arch="x86_64" os="LINUX">
        <grid  type="gt2" contact="${CLUSTER_HOSTNAME}/jobmanager-fork" scheduler="Fork" jobtype="auxillary"/>
        <grid  type="gt2" contact="${CLUSTER_HOSTNAME}/jobmanager-${CLUSTER_SCHEDULER}" scheduler="unknown" jobtype="compute"/>
        <head-fs>
            <scratch>
                <shared>
                    <file-server protocol="gsiftp" url="gsiftp://${CLUSTER_HOSTNAME}" mount-point="${CLUSTER_WORK_DIR}"/>
                    <internal-mount-point mount-point="${CLUSTER_WORK_DIR}"/>
                </shared>
            </scratch>
            <storage>
                <shared>
                    <file-server protocol="gsiftp" url="gsiftp://$CLUSTER_HOSTNAME" mount-point="$CLUSTER_WORK_DIR"/>
                    <internal-mount-point mount-point="${CLUSTER_WORK_DIR}"/>
                </shared>
            </storage>
        </head-fs>
        <replica-catalog  type="LRC" url="rlsn://dummyValue.url.edu" />
        <profile namespace="env" key="PEGASUS_HOME" >${CLUSTER_PEGASUS_HOME}</profile> 
        <profile namespace="env" key="GLOBUS_LOCATION" >${CLUSTER_GLOBUS_LOCATION}</profile>
    </site>
</sitecatalog>
"""
    def generateXML (self, map):
        template = Template (self.xml)
        return template.safe_substitute (map)
	
# 
#abstract representation of an element comprising
#- a graph node
#- properties of the node
#- a dax node
#
class DAXElementExt:

    def __init__(self, node):
        self.ATTR_TYPE = "type"
        self.node = node
        self.properties = { "id" : self.node.getId () }
        self.daxNode = None
        properties = self.parseProperties ()
        if properties:
            self.setProperties (properties)
            
    def parseProperties (self):
        properties = None
        id = self.node.getId ()
        text = self.node.getType ()
        if id and text:
            try:
                text = string.replace (text, "\n", " ")
                properties = json.loads (text)
            except:
                logging.error ("(error) {json-parse-error} (%s)->(%s)" % (id, text))
                self.setProperties ({ "type" : None })
                traceback.print_exc ()
        return properties

    def getProperties (self):
        return self.properties
	
    def setProperties (self, properties):
        logging.debug ("         -{set-properties} (%s)->(%s)" % (self.node.getId(),
                                                                        properties))
        if not properties:
            properties = {}
        self.properties = properties
        self.properties ["id"] = self.node.getId ()
            
    def addAncestor (self, ancestor):
        if ancestor:
            self.mergePropertiesFrom (ancestor)
            
    def addProfiles (self, other):
        if other:
            self.mergePropertiesFrom (other, tag="inherit-profiles")

    def mergePropertiesFrom (self, other, exceptions=["id", "type"], tag="inherit"):
        if other:
            self.properties = self.mergePropertiesDeep (self.properties,
                                                        other.getProperties (),
                                                        exceptions)
            logging.debug ("  +{%s} obj(%s)->anc(%s)=[%s]" % 
                          (tag,
                           self.node.getLabel(),
                           other.getNode().getLabel (),
                           self.properties))
            
    def mergePropertiesDeep (self, left, right, exceptions=[]):
        if left and right:
            for key in right:
                if key in exceptions:
                    continue
                value = right [key]
                if key in left:
                    if type(value) == dict:
                        value = self.mergePropertiesDeep (left[key], value)
                    else:
                        left [key] = value
                        logging.debug (" -{copy-key}: left[%s]->[%s]" % (key, value))
                else:
                    left [key] = right [key]
                    logging.debug ("   -{copy-key}: left[%s]->[%s]" % (key, value))
        return left

    def get (self, key):
        value = None
        if key in self.properties:
            value = self.properties [key]
        return value
	
    def getLabel (self):
        return self.node.getLabel ()
    
    def getNode (self):
        return self.node

    def getType (self):
        return self.get(self.ATTR_TYPE)
    
    def setDaxNode (self, daxNode):
        self.daxNode = daxNode

    def getDaxNode (self):
        return self.daxNode
    
    def getProfiles (self):
        profiles = None
        if self.properties:
            profileList = None
            if 'profiles' in self.properties:
                profileList = self.properties ['profiles']
                if profileList:
                    profiles = []
                    for namespace in profileList:
                        space = profileList [namespace]
                        for key in space:
                            if key:
                                value = space [key]
                                if value:
                                    logging.info ("                 {get-profiles} (%s)-(%s=%s)" % (namespace, key, value))
                                    profile = Profile (namespace, key, value)
                                    profiles.append (profile)
        return profiles

    def getNodeOrigins (self, graph):
        origins = []
        if self.node:
            edges = graph.getEdges ()
            id = self.node.getId ()
            for edge in edges:
                # this edge points at this node #
                if edge.getTarget () == id:
                    origin = graph.getNode (edge.getSource ())
                    # record the originating node #
                    if origin:
                        logging.info ("        {add-origin} (%s) of (%s)" % (origin.getLabel(), self.getNode().getLabel()) )
                        origins.append (origin.getId ())
        return origins

# An extended version of a Pegasus ADAG #
class ADAGExt:
    
    def __init__(self, adag, namespace, dataPrefix=""):
        self.adag = ADAG (namespace)
        self.namespace = namespace
        self.files = {}
        self.exes = {}
        self.propertyMap = {}
        self.nodes = {}

        self.dataPrefix = dataPrefix
        
    def setProperties (self, nodeId, properties):
        logging.debug ("        ==> {set-properties} (%s)->(%s)" % (nodeId, properties))
        self.propertyMap [nodeId] = properties
        
    def getProperties (self, nodeId):
        return self.propertyMap [nodeId]
    
    def addNode (self, id, node):
        logging.debug ("        ==> {add-node} (%s)->(%s)" % (node.getId(), properties))
        self.nodes [id] = node

    def getNode (self, id):
        node = None
        if id in self.nodes:
            node = self.nodes [id]
            return node
        
    def addFile (self, fileName, prefix=""):
        file = self.getFile (fileName)
        if not file:
            fileName = "%s%s" % (prefix, fileName)
            file = File (fileName)
            file.addPFN(PFN ("file://%s/%s" % (os.getcwd(), fileName), "local"))
            self.adag.addFile (file)
            self.files[fileName] = file
        return file
	
    def getFile (self, fileName, prefix=""):
        key = "%s%s" % (prefix, fileName)
        if key in self.files:
            logging.debug ("            -{get-file} (%s)" % key)
            return self.files [key]
        else:
            return None
	
    def addExecutable (self, name, path, version="4.0", exe_os="linux", exe_arch="x86_64", site="local", installed="true"):
        e_exe = Executable (
            namespace=self.namespace, 
            name=name, 
            version=version, 
            os=exe_os, 
            arch=exe_arch, 
            installed=installed)
        logging.debug ("       -{add-exe} (name=[%s], path=[%s], version=[%s], os=[%s], arch=[%s], site=[%s], installed=[%s])" % 
                       (name,
                        path,
                        version,
                        exe_os,
                        exe_arch,
                        site,
                        installed))        
        workingDir = os.getcwd ()
        path = path.replace ("${appHome}", workingDir)
        e_exe.addPFN (PFN ("file://%s" % path, site))
        self.adag.addExecutable (e_exe)
        self.exes[path] = e_exe
        return e_exe
    
    def getExecutable (self, name):
        key = name
        if key in self.exes:
            return self.exes [key]
        else:
            return None
	
    def getADAG (self):
        return self.adag

# Test Job #
class DAXTestJob:

    def __init__(self, name, executable=None):
        self.name = name
        self.executable = executable
        self.args = []
        self.children = []
        self.map = {}

    def addArguments (self, args):
        if args:
            for arg in args:
                self.args.append (arg)

    def getText (self):
        value = None
        if self.executable:
            value = "python %s" % self.executable
            for arg in self.args:
                value = "%s %s" % (value, arg)
        return value

    def addChild (self, child):
        self.children.append (child)

    def getChildren (self):
        return self.children

    def execute (self, executor):
        commandLine = self.getText ()
        if commandLine:
            logging.info ("--{execute-job} %s: command[%s] " % (self.name, commandLine))
            executor.execute (commandLine)
            for job in self.children:
                logging.info ("--current working directory is: %s" % os.getcwd ())
                job.execute (executor)

class DaxContext:
    def __init__(self):
        self.dependencies = {}
        self.daxJobs = {}
    def addDaxJob (self, id, job):
        self.daxJobs [id] = job
    def getDaxJobs (self):
        return self.daxJobs
    def getDaxJob (self, id):
        value = None
        if id in self.daxJobs:
            value = self.daxJobs [id]
        return value
    def addDependency (self, id, dependencies):
        self.dependencies[id] = dependencies
    def getDependencies (self, id):
        value = None
        if id in self.dependencies:
            value = self.dependencies [id]
        return value
        
class JobContext:
    def __init__(self, job, namespace, version):
        self.job = job
        self.transformation = Transformation (self.job.getNode().getLabel(), namespace, version)
        self.testJob = None
        self.origins = []
        self.inputFiles = []
        self.outputFiles = []
    def getJob (self):
        return self.job
    def setTransformation (self, transformation):
        self.transformation = transformation
    def getTransformation (self):
        return self.transformation
    def setTestJob (self, testJob):
        self.testJob = testJob
    def getTestJob (self):
        return self.testJob
    def addOrigin (self, origin):
        self.origins.append (origin)
    def getOrigins (self):
        return self.origins
    def addOutputFile (self, entry):
        self.outputFiles.append (entry)
    def getOutputFiles (self):
        return self.outputFiles
    def addInputFile (self, entry):
        self.inputFiles.append (entry)
    def getInputFiles (self):
        return self.inputFiles
        
# Read a graph structure and convert to Pegasus DAX semantics #
class GraphML2DAX:

    def __init__(self, namespace, version, logLevel="warning", test=False, clean=False):
        self.DAX_INPUT = "in"
        self.DAX_OUTPUT = "out"
        self.DAX_EXECUTABLE = "executable"
        self.DAX_FILE = "file"
        self.DAX_JOB = "job"
        self.DAX_WORKFLOW = "workflow"
        self.DAX_PROPERTIES = "properties"
        self.DAX_ABSTRACT = "abstract"
        self.DAX_CONTEXT_MODEL = "-context.graphml"

        self.DAX_ATTR_LOCAL = "local"
        self.DAX_ATTR_TYPE = "type"
        self.DAX_ATTR_PATH = "path"
        self.DAX_ATTR_SITE = "site"
        self.DAX_ATTR_INSTALLED = "installed"
        self.DAX_ATTR_ARG  = "arg"
        self.DAX_ATTR_REFERENCE  = "reference"
        self.DAX_ATTR_VERSION  = "version"

        self.GRAYSON_FILE_ARG = "grayson.file.arg"
        self.GRAYSON_REDIRECT_OUTPUT_TO = "grayson.redirect.output.to"

        self.loggingLevel = logLevel
        self.fileLogging = False
        self.logDirectory = "logs"
        self.logLevels = {
            'debug'    : logging.DEBUG,
            'info'     : logging.INFO,
            'warning'  : logging.WARNING,
            'error'    : logging.ERROR,
            'critical' : logging.CRITICAL
            }

        self.initLogging ()

        self.namespace=namespace
        self.version=version

        self.graph = None

        self.extdag = ADAGExt (ADAG(namespace), namespace, "input/")
        self.daxElements = {}
        self.typeIndex = {}
        self.labelIndex = {}
        self.validModel = True
        self.errorMessages = []

        self.properties = DAXElementExt (Node ("x", "{}", ""))

        self.test = test
        self.clean = clean
        self.testJobs = {}
        self.roots = []-

        self.contextModels = []
        self.modelPath = [ "models" ]

    def getProperty (self, key):
        return self.properties.get (key)
	
    def initLogging (self):
        level = self.logLevels [self.loggingLevel]
        logdirectory = self.logDirectory
        handler = None
        if not os.path.exists (logdirectory):
            os.makedirs (logdirectory)
        logFile = os.path.join (logdirectory, "graphml2DAX.log")
        if self.fileLogging == True:
            handler = logging.handlers.RotatingFileHandler (logFile,
                                                            maxBytes=10000000,
                                                            backupCount=3)
        else:
            handler = logging.StreamHandler (sys.stdout)
        root_logger = logging.getLogger ()
        root_logger.setLevel (level)
        formatter = logging.Formatter ("%(asctime)s - %(levelname)s - %(message)s")
        handler.setFormatter (formatter)
        root_logger.addHandler (handler)
            
    def setLogLevel (self, level):
        oldLevel = None
        if level:
            logger = logging.getLogger ()
            oldLevel = self.loggingLevel
            self.loggingLevel = level
            logger.setLevel (self.logLevels [level])
            return oldLevel

    def loadGraphs (self, files, subgraph=False):
        models = None
        if subgraph:
            models = copy.copy (self.contextModels)
            models.append (model)
        else:
            for model in files:
                if string.find (model, self.DAX_CONTEXT_MODEL) > -1:
                    logging.info ("   --noting context model: (%s)" % model)
                    self.contextModels.append (model)
            models = files

        parser = GraphMLParser ()
        self.graph = parser.parseMultiple (files, path=self.modelPath)
        
    def addElement (self, id, element):
        type = element.get (self.DAX_ATTR_TYPE)
        self.daxElements [id] = element
        if type:
            if not type in self.typeIndex:
                self.typeIndex[type] = []
                self.typeIndex [type].append (element)
                
            node = element.getNode ()
            if isinstance (node, Node) and not type == self.DAX_ATTR_REFERENCE:
                label = node.getLabel ()
                if label:
                    self.labelIndex [label] = element

    def getElementByLabel (self, label):
        value = None
        if label in self.labelIndex:
            value = self.labelIndex [label]
        return value

    def getElementsByType (self, type):
        value = None
        if type in self.typeIndex:
            value = self.typeIndex [type]
        return value

    def getElementKeys (self):
        return self.daxElements.keyiter ()

    def getElement (self, id):
        value = None
        if id in self.daxElements:
            value = self.daxElements [id]
            if value:
                type = value.get (self.DAX_ATTR_TYPE)
                if type == self.DAX_ATTR_REFERENCE:
                    referencedValue = None
                    node = value.getNode ()
                    if node:
                        label = node.getLabel ()
                        if label:
                            referencedValue = self.getElementByLabel (label)
                            if referencedValue:
                                logging.info ("  +{dereference} (%s) to object (%s)" % 
                                              (label,
                                               referencedValue.getNode().getLabel ()))
                                value = referencedValue
                            else:
                                logging.error ("unable to find concrete object referenced by label: %s" % value.getNode().getLabel ())
                                value = None
        return value

    def addFiles (self, job, fileDs, defaultFlag="-i", link=Link.INPUT, testJob=None):
        if fileDs:
            for fileD in fileDs:
                if fileD:
                    fileElement = fileD [self.DAX_FILE]
                    if fileElement:
                        daxFile = fileD[self.DAX_FILE].getDaxNode ()
                        daxJob = job.getDaxNode ()
                        if daxJob:
                            logging.info ("        {add-files} file=%s" % fileElement.getNode().getLabel ())
                            if daxFile:
                                daxJob.uses (daxFile, link=link)
                                flag = fileD ['arg']
                                if flag:
                                    logging.debug ("         -{flag} %s" % flag)
                                    
                                    if flag == self.GRAYSON_FILE_ARG:
                                        flag = ""
                                    if flag == self.GRAYSON_REDIRECT_OUTPUT_TO:
                                        flag = ">"
                                    daxJob.addArguments (flag, daxFile)
                                    if testJob:
                                        testJob.addArguments ([ flag, 
                                                                fileElement.getNode().getLabel ()
                                                                ])

    def addError (self, message):
        self.errorMessages.append (message)
    def reportErrors (self):
        for message in self.errorMessages:
            logging.error ("--error: %s" % message)

    def failValidation (self, message):
        self.addError (message)
        self.validModel = False
        
    def validateGraph (self):
        nodes = self.graph.getNodes ()
        if not nodes:
            self.addError ("the graph is empty (contains no nodes)")
            edges = self.graph.getEdges ()
            if not edges:
                self.addError ("the graph is empty (contains no edges)")

                
                #

                #Check for cycles.

                # L <= Empty list where we put the sorted elements
                # Q <= Set of all nodes with no incoming edges
                # while Q is non-empty do
                #     remove a node n from Q
                #     insert n into L
                #     for each node m with an edge e from n to m do
                #         remove edge e from the graph
                #         if m has no other incoming edges then
                #             insert m into Q
                # if graph has edges then
                #     output error message (graph has a cycle)
                # else 
                #     output message (proposed topologically sorted order: L)
                #
    def validateModel (self):
        logging.debug ("+{validate-graph}")
        for key in self.daxElements.iterkeys ():
            element = self.getElement (key)
            if element:
                if element.get (self.DAX_ATTR_TYPE) == self.DAX_FILE:
                    fileName = element.getNode().getLabel ()
                    if not os.path.exists (fileName):
                        self.failValidation ("File: %s does not exist." % fileName)

    def addExecutable (self, jobContext, source):
        job = jobContext.getJob ()
        jobLabel = job.getNode().getLabel ()
        logging.info ("      +{add-executable} %s" % jobLabel)
        transformation = Transformation (jobLabel, self.namespace, self.version)
        transformation.uses (jobLabel)
        jobContext.setTransformation (transformation)
        site = source.get (self.DAX_ATTR_SITE)
        path = source.get (self.DAX_ATTR_PATH)
        installed = source.get (self.DAX_ATTR_INSTALLED)
        exe = self.extdag.addExecutable (name = jobLabel,
                                         path = path,
                                         version = self.version,
                                         site = site,
                                         installed = installed)
        source.setDaxNode (exe)
        job.addProfiles (source)
        jobContext.setTestJob (DAXTestJob (jobLabel, path))

    def addOutputFile (self, jobContext, fileElement, edge):
        job = jobContext.getJob ()
        fileName = fileElement.getNode().getLabel ()
        file = File (fileName)
        fileElement.setDaxNode (file)
        arg = edge.get (self.DAX_ATTR_ARG)
        logging.info ("      +{add-output} arg=%s file=%s source=%s" % 
                      (arg,
                       fileName,
                       job.getNode().getLabel ()) )
        jobContext.addOutputFile (
            { self.DAX_FILE      : fileElement,
              self.DAX_ATTR_ARG  : arg 
              })
        jobContext.getTransformation().uses (file)

    def addInputFile (self, jobContext, fileElement, edge):
        job = jobContext.getJob ()
        fileName = fileElement.getNode().getLabel ()
        prefix = ""
        file = self.extdag.addFile (fileName, prefix)
        fileElement.setDaxNode (file)
        arg = edge.get (self.DAX_ATTR_ARG)
        if file:
            jobContext.addInputFile ({ self.DAX_FILE     : fileElement,
                                       self.DAX_ATTR_ARG : arg })
            jobContext.getTransformation().uses (file)
            logging.info ("      +{add-input}  arg=%s file=%s job=%s" % 
                          (arg,
                           fileName,
                           job.getNode().getLabel () ))

            inputOrigins = fileElement.getNodeOrigins (self.graph)
            for o in inputOrigins:
                logging.info ("         -{origin}: %s" % o)
                jobContext.addOrigin (o)

    # 
    # Write precedence information 
    # Develop precedence hierarchy for test jobs
    # Record root jobs
    #
    def buildDAXCreateDependencies (self, daxContext):
        logging.info ("+{job-dependencies} ")
        self.roots = []
        daxJobs = daxContext.getDaxJobs ()
        for jobId in daxJobs:
            job = daxContext.getDaxJob (jobId)
            logging.info ("  +{job-id} %s" % jobId)
            dependencySet = daxContext.getDependencies (jobId)
            if dependencySet:
                for key in dependencySet:
                    dependency = None
                    logging.info ("        -{depKey} (%s)" % key)
                    dependency = daxContext.getDaxJob (key)
                    if dependency:
                        logging.info ("        -{add-dependency} (%s)=>(%s)" % (jobId, key))
                        self.extdag.getADAG().addDependency (parent = dependency, child  = job)
                        
                        parentTestJob = self.testJobs [key]
                        childTestJob = self.testJobs [jobId]
                        if childTestJob and parentTestJob:
                            parentTestJob.addChild (childTestJob)                                
                    else:
                        # doesn't have a dependency set #
                        self.roots.append (jobId)
                        
    # Establish property context #
    def buildDAXProperties (self):
        propertyNode = self.graph.getProperties ()
        if propertyNode:
            self.properties = DAXElementExt (propertyNode)
            if self.test:
                testProperties = self.getProperty ("testMap")
                if testProperties:
                    map = self.getProperty ("map")
                    if map:
                        map.update (testProperties)
                        logging.info ("--updated properties to test mode\n   %s" % map)

    # Map nodes (and property resolution) #
    def buildDAXMapNodes (self):

        print ("================================================= workflow")
        logging.debug ("+{map-nodes}")		
        jobs = []
        nodes = self.graph.getNodes ()
        for node in nodes:
            jsonText = node.getType ()
            if jsonText and jsonText.find ("$") > -1:
                template = Template (jsonText)
                properties = self.properties.getProperties ()
                if "map" in properties:
                    map = self.getProperty ("map")
                    jsonText = template.safe_substitute (map)
                    node.setType (jsonText)
                    logging.info ("   --setting type: (%s)" % jsonText)
            element = DAXElementExt (node)
            self.addElement (node.getId (), element)
            type = element.get ('type')
            if type == self.DAX_JOB:
                jobs.append (element)
# sub-workflow: treat workflows just like jobs
            elif type == self.DAX_WORKFLOW:
                jobs.append (element)

                logging.info ("================================================= workflow")
                self.buildDAXCompileWorkflow (element)

        return jobs

    # Map edges #
    def buildDAXMapEdges (self):
        logging.debug ("+{map-edges}")		
        edgeElements = []
        edges = self.graph.getEdges ()
        for edge in edges:
            element = DAXElementExt (edge)
            self.addElement (edge.getId (), element)
            edgeElements.append (element)            
        return edgeElements

    # Dereference #
    def buildDAXDereference (self):
        logging.debug ("+{dereference}")		
        nodes = self.graph.getNodes ()
        for node in nodes:
            refId = node.getId ()
            element = self.getElement (node.getId ())
            if element:
                nodeId = element.getNode().getId ()
                if refId != nodeId: 
                    # node is a reference #
                    edges = self.graph.getEdges ()
                    for edge in edges:
                        if edge.getTarget() == refId: 
                            # for every edge pointing to the reference #
                            edge.setTarget (nodeId)
                            
    # Inherit #
    def buildDAXInherit (self):
        logging.debug ("+{effect-inheritance}")		
        nodes = self.graph.getNodes ()
        for node in nodes:
            element = self.getElement (node.getId ())
            if element and element.getType () != self.DAX_ATTR_REFERENCE: 
                origins = element.getNodeOrigins (self.graph)
                for originId in origins:
                    originElement = self.getElement (originId)
                    if originElement:
                        if originElement.getType () == self.DAX_ABSTRACT:
                            logging.info ("  +{inherit} base(%s) to derived(%s)" % 
                                          (originElement.getNode().getLabel (),
                                           element.getNode().getLabel ()))
                            element.addAncestor (originElement)


    def buildDAXCompileWorkflow (self, element):
        elementName = element.getLabel ()
        logging.info ("  +{workflow} (%s)" % elementName )
        compiler = GraphML2DAX (namespace = elementName,
                                version = element.get (self.DAX_ATTR_VERSION), 
                                logLevel = self.logingLevel,
                                test = self.test,
                                clean = self.clean)
        
        compiler.loadGraphs (models=[ model ], subgraph=True)
        compiler.buildDAX ()
        compiler.writeDAX ("%s.dax" % elementName)

    # really #                   
    def buildDAX (self):
        logging.debug ("+{build-dax}")		
        daxContext = DaxContext ()
        self.buildDAXProperties ()
        jobs = self.buildDAXMapNodes ()
        edgeElements = self.buildDAXMapEdges ()
        self.buildDAXDereference ()
        self.buildDAXInherit ()		
        # Build jobs #
        for job in jobs:
            jobId = job.getNode().getId ()
            jobLabel = job.getNode().getLabel ()
            logging.info ("  +{analyze-job} name=%s, id=%s" % (jobLabel, jobId))
            jobContext = JobContext (job, self.namespace, self.version)
            for edge in edgeElements:
                edgeTarget = edge.getNode().getTarget ()
                source = self.getElement (edge.getNode().getSource ())
                # an output file can be the target end of an edge from a job #
                if edge.getNode().getSource () == jobId and edge.get (self.DAX_ATTR_TYPE) == self.DAX_OUTPUT:
                    fileElement = self.getElement (edgeTarget)
                    self.addOutputFile (jobContext, fileElement, edge)
                elif edgeTarget == jobId:
                    # some file, executable or other modifier to a job. #
                    if source:
                        if source.get (self.DAX_ATTR_TYPE) == self.DAX_EXECUTABLE:
                            # an executable can be the source end of an edge to a job #
                            self.addExecutable (jobContext, source)
                        elif edge.get (self.DAX_ATTR_TYPE) == self.DAX_INPUT:
                            # an input file can be the source end of an edge to a job #
                            self.addInputFile (jobContext, source, edge)

            transformation = jobContext.getTransformation ()
            testJob = jobContext.getTestJob ()
            aJob = Job (transformation)
            job.setDaxNode (aJob)

            # Inherit executable profiles #
            profiles = job.getProfiles ()
            if profiles:
                for profile in profiles:
                    logging.info ("        +{add-profiles} adding profile (%s) to job (%s)" % (profile, job))
                    aJob.addProfile (profile)
                    
            # Add files #
            self.addFiles (job, jobContext.getInputFiles(), "-i", Link.INPUT, testJob) 
            self.addFiles (job, jobContext.getOutputFiles(), "-o", Link.OUTPUT, testJob)

            daxContext.addDaxJob (jobId, aJob)
            daxContext.addDependency (jobId, jobContext.getOrigins ())
            adag = self.extdag.getADAG ()
            adag.addTransformation (transformation)
            adag.addJob (aJob)

            self.testJobs[jobId] = testJob

        self.buildDAXCreateDependencies (daxContext)

    # test #
    def executeTest (self):

        cwd = os.getcwd ()
        
        targetDir = "target"
        appHome = "appHome"
        if self.clean:
            shutil.rmtree (targetDir, True)
            time.sleep (0.5)
            
        if not os.path.exists (targetDir):
            os.makedirs (targetDir)
        os.chdir (targetDir)

        logging.info ("--executing tests")
        logging.info ("--current working directory is: %s" % os.getcwd ())

        testProperties = self.getProperty ("testProperties")
        if not testProperties:
            testProperties = {}
        testProperties[appHome] = cwd

        executor = Executor (testProperties)
        
        level = self.setLogLevel ("info")
        for root in self.roots:
            testJob = self.testJobs [root]
            if testJob:
                testJob.execute (executor)
        self.setLogLevel (level)

    # write #
    def writeDAX (self, stream=sys.stdout):
        self.extdag.getADAG().writeXML (stream)

    # usage #
    def usage0 ():
        logger = logging.getLogger ()
        logger.setLevel (logging.INFO)
        logging.info ("usage: graysonc")
        logging.info ("  -m|--model      a model file to compile")
        logging.info ("  -o|--output     the name of the output DAX file")
        logging.info ("  -n|--namespace  the namespace of the application")
        logging.info ("  -v|--version    application version")
        logging.info ("  -s|--site       generate the sites.xml file from information in the model")
        logging.info ("  -l|--loglevel   set logging level to [debug|info|warning|info|critical]")
        logging.info ("  -t|--test       execute a local test of the workflow")
        logging.info ("  -c|--clean      clean the target directory before running the test")
        logging.info ("  -h|--help       show this message")

    # main #
    def main0 (argv):
        models = []
        output = sys.stdout
        verbose = False
        namespace = "app"
        version = "1.0"
        generateSite = False	
        test = False
        clean = False
        logLevel = "warning"
        try:
            opts, args = getopt.getopt ( argv, "m:o:n:r:l:shtc",
                                         [ "model=",
                                           "output=", 
                                           "namespace=",
                                           "version=",
                                           "loglevel=",
                                           "site",
                                           "test",
                                           "clean",
                                           "help"
                                           ] )
            for opt, arg in opts:
                if opt in ("-m", "--model"):
                    models.append (arg)
                elif opt in ("-o", "--output"):
                    output = open (arg, "w")
                elif opt in ("-n", "--namespace"):
                    namespace = arg
                elif opt in ("-r", "--version"):
                    version = arg
                elif opt in ("-v", "--verbose"):
                    verbose = True
                elif opt in ("-s", "--site"):
                    generateSite = True
                elif opt in ("-l", "--loglevel"):
                    logLevel = arg
                elif opt in ("-t", "--test"):
                    test = True
                elif opt in ("-c", "--clean"):
                    clean = True
                elif opt in ("-h", "--help"):
                    usage ()
                    sys.exit ()
                else:
                    usage ()
                    sys.exit ()
                
            if len(models) == 0:
                usage ()
                sys.exit ()
            else:
                compiler = GraphML2DAX (namespace, version, logLevel, test, clean)
                compiler.loadGraphs (models)
                compiler.buildDAX ()
                compiler.writeDAX (output)
            
                if output != sys.stdout:
                    output.close ()
                
                if test:
                    compiler.executeTest ()

                if generateSite:
                    site = compiler.getProperty ("site")
                    if site:
                        site ["TOPDIR"] = os.getcwd ()
                        pegasusHome = os.getenv ("PEGASUS_HOME")
                        site ["PEGASUS_HOME"] = pegasusHome
                        site ["GLOBUS_LOCATION"] = os.getenv ("GLOBUS_LOCATION")
                        siteFile = open ("sites.xml", "w")
                        xml = SiteXML ()
                        siteText = xml.generateXML (site)
                        siteFile.write (siteText)
                        siteFile.close ()
	
        except getopt.GetoptError, ex:
            usage ()
            formatted_lines = traceback.format_exc().splitlines()
            print formatted_lines[-1]

__version__ = '0.1'
__all__ = [ "GraphML2DAX" ]
__author__ = 'Steve Cox <scox@renci.org>'
  
