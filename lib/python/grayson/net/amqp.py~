import sys
import time
import traceback

import pika
from os.path import exists, normpath
from pika.adapters import SelectConnection
from pika.adapters import AsyncoreConnection
from pika.connection import ConnectionParameters
from pika import BasicProperties
import pika.log

#pika.log.setup(level=pika.log.INFO)


class GraysonAMQP(object):

    def __init__(self):
        self.queue = "default"
                
    def connect (self, hostname="127.0.0.1"):
        self.channel = None
        self.connection = AsyncoreConnection(ConnectionParameters(hostname),
                                             self.on_connected)

    def setQueue (self, name):
        self.queue = name

    def setQueueDeclaredCallback (self, queueDeclaredCallback):
        self.queueDeclaredCallback = queueDeclaredCallback

    def ioloop (self):
        self.connect ()
        try:
            self.connection.ioloop.start()
        except KeyboardInterrupt:
            self.connection.close()
            self.connection.ioloop.start()

    def on_connected(self, connection):
        connection.channel(self.on_channel_open)

    def on_channel_open(self, channel_):
        self.channel = channel_
        self.channel.queue_declare (queue=self.queue,
                                    passive=False,
                                    durable=True,
                                    exclusive=False,
                                    auto_delete=False,
                                    callback=self.on_queue_declared)

    def on_queue_declared(self, frame):
        try:
            self.queueDeclaredCallback (frame)
        except:
            trackeback.print_stack ()
        finally:
            pass
        #self.connection.close()

class GraysonAMQPTransmitter (GraysonAMQP):

    def __init__(self, queue=None, hostname=None):
        super(GraysonAMQPTransmitter, self).__init__() 
        self.setQueueDeclaredCallback (self.transmit)
        self.setQueue (queue)

    def send (self, buffer):
        self.buffer = buffer
        self.ioloop ()

    def transmit (self, frame):
        while len (self.buffer) > 0:
            message = self.buffer.pop (0)
            properties = BasicProperties(timestamp=time.time(),
                                         app_id=__file__,
                                         user_id='guest',
                                         content_type="text/plain",
                                         delivery_mode=1)
            self.channel.basic_publish(exchange='',
                                       routing_key=self.queue,
                                       body=message,
                                       properties=properties)
        self.connection.close()

class GraysonAMQPReceiver (GraysonAMQP):

    def __init__ (self, queue=None, hostname=None):
        super(GraysonAMQPReceiver, self).__init__() 
        self.setQueueDeclaredCallback (self.do_receive)
        self.setQueue (queue)

    def receive (self, processor=None):
        self.processor = processor
        self.ioloop ()

    def do_receive (self, frame):        
        self.channel.basic_consume (self.handle_delivery, queue=self.queue)

    def handle_delivery(self, channel, method_frame, header_frame, body):
        '''
        print "Basic.Deliver %s delivery-tag %i: %s" % (header_frame.content_type,
                                                        method_frame.delivery_tag,
                                                        body)
                                                        '''
        if self.processor:
            self.processor (body)
        self.channel.basic_ack(delivery_tag=method_frame.delivery_tag)
        self.connection.close()

__all__ = [ "GraysonAMQPReceiver", "GraysonAMQPTransmitter" ]
